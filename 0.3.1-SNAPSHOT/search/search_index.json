{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KFixture \u00b6 A tool to generate randomized test values for Kotlin Multiplatform. About The Project \u00b6 Tired of writing potato or 42 for your test values? - KFixture is a (limited) extendable generator test value generator for Kotlin Multiplatform which can help you out there. The project is heavily influenced by appmattus kotlinfixture and inspired by Kotest Generators . If you want to know more take a look into the Documentation . Dependencies \u00b6 Kotlin 1.7.10 AtomicFu 0.18.3 Touchlab's Stately 1.2.3 Android 5.0 (API 21) to Android 13 (API 33) Changelog \u00b6 See changelog . Versioning \u00b6 This project uses Semantic Versioning as a guideline for our versioning. Contributing \u00b6 You want to help or share a proposal? You have a specific problem? Read the following: Code of Conduct for details on our code of conduct. Contribution Guide for details about how to report bugs and propose features. Releasing \u00b6 Please take a look here . Copyright and License \u00b6 Copyright \u00a9 2022 Matthias Geisler / All rights reserved. Please refer to the License for further details.","title":"Home"},{"location":"#kfixture","text":"A tool to generate randomized test values for Kotlin Multiplatform.","title":"KFixture"},{"location":"#about-the-project","text":"Tired of writing potato or 42 for your test values? - KFixture is a (limited) extendable generator test value generator for Kotlin Multiplatform which can help you out there. The project is heavily influenced by appmattus kotlinfixture and inspired by Kotest Generators . If you want to know more take a look into the Documentation .","title":"About The Project"},{"location":"#dependencies","text":"Kotlin 1.7.10 AtomicFu 0.18.3 Touchlab's Stately 1.2.3 Android 5.0 (API 21) to Android 13 (API 33)","title":"Dependencies"},{"location":"#changelog","text":"See changelog .","title":"Changelog"},{"location":"#versioning","text":"This project uses Semantic Versioning as a guideline for our versioning.","title":"Versioning"},{"location":"#contributing","text":"You want to help or share a proposal? You have a specific problem? Read the following: Code of Conduct for details on our code of conduct. Contribution Guide for details about how to report bugs and propose features.","title":"Contributing"},{"location":"#releasing","text":"Please take a look here .","title":"Releasing"},{"location":"#copyright-and-license","text":"Copyright \u00a9 2022 Matthias Geisler / All rights reserved. Please refer to the License for further details.","title":"Copyright and License"},{"location":"changelog/","text":"Changelog \u00b6 All important changes of this project must be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 Changed \u00b6 Deprecated \u00b6 Removed \u00b6 Fixed \u00b6 Security \u00b6 Bumped \u00b6 Unreleased \u00b6 Added \u00b6 Support for KTX DateTime: Instant DayOfWeek Month TimeZone DateTimePeriod DatePeriod UtcOffset FixedOffsetTimeZone LocalTime LocalDate LocalDateTime Fixed \u00b6 Special Arrays (like CharArray) did not work with ranges Bumped \u00b6 Gradle 7.5 -> 7.5.1 Kotlin 1.7.0 -> 1.7.10 AtomicFu 0.18.2 -> 0.18.3 Android Target SDK 32 -> 33 0.3.1 \u00b6 Fixed \u00b6 Dangled Signatures 0.3.0 \u00b6 Added \u00b6 SelectorGenerator RangedGenerator for: UByte Short UShort UInt ULong Float Char SignedNumberGenerator for: Byte Short Int Long Double RangedArrayGenerator for: UByteArray UShortArray UIntArray ULongArray FloatArray CharArray String SignedArrayNumberGenerator for: ByteArray ShortArray IntArray LongArray DoubleArray BooleanArrayGenerator is now a ArrayGenerator DependentGeneratorFactory in order to build Generators on top of other Generators Filter custom generator for Generics support for Enums Changed \u00b6 iterable of fixture is now called option Bumped \u00b6 Gradle 7.4.2 -> 7.5 Kotlin 1.6.21 -> 1.7.0 AtomicFu 0.17.3 -> 0.18.2 Stately 1.2.1 -> 1.2.3 Android Target SDK 31 -> 32 0.2.0 \u00b6 Bumped \u00b6 Kotlin 1.6.10 -> 1.6.21 AtomicFu 0.17.1 -> 0.17.3 0.1.0 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All important changes of this project must be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"","title":"Added"},{"location":"changelog/#changed","text":"","title":"Changed"},{"location":"changelog/#deprecated","text":"","title":"Deprecated"},{"location":"changelog/#removed","text":"","title":"Removed"},{"location":"changelog/#fixed","text":"","title":"Fixed"},{"location":"changelog/#security","text":"","title":"Security"},{"location":"changelog/#bumped","text":"","title":"Bumped"},{"location":"changelog/#unreleased_1","text":"","title":"Unreleased"},{"location":"changelog/#added_1","text":"Support for KTX DateTime: Instant DayOfWeek Month TimeZone DateTimePeriod DatePeriod UtcOffset FixedOffsetTimeZone LocalTime LocalDate LocalDateTime","title":"Added"},{"location":"changelog/#fixed_1","text":"Special Arrays (like CharArray) did not work with ranges","title":"Fixed"},{"location":"changelog/#bumped_1","text":"Gradle 7.5 -> 7.5.1 Kotlin 1.7.0 -> 1.7.10 AtomicFu 0.18.2 -> 0.18.3 Android Target SDK 32 -> 33","title":"Bumped"},{"location":"changelog/#031","text":"","title":"0.3.1"},{"location":"changelog/#fixed_2","text":"Dangled Signatures","title":"Fixed"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#added_2","text":"SelectorGenerator RangedGenerator for: UByte Short UShort UInt ULong Float Char SignedNumberGenerator for: Byte Short Int Long Double RangedArrayGenerator for: UByteArray UShortArray UIntArray ULongArray FloatArray CharArray String SignedArrayNumberGenerator for: ByteArray ShortArray IntArray LongArray DoubleArray BooleanArrayGenerator is now a ArrayGenerator DependentGeneratorFactory in order to build Generators on top of other Generators Filter custom generator for Generics support for Enums","title":"Added"},{"location":"changelog/#changed_1","text":"iterable of fixture is now called option","title":"Changed"},{"location":"changelog/#bumped_2","text":"Gradle 7.4.2 -> 7.5 Kotlin 1.6.21 -> 1.7.0 AtomicFu 0.17.3 -> 0.18.2 Stately 1.2.1 -> 1.2.3 Android Target SDK 31 -> 32","title":"Bumped"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#bumped_3","text":"Kotlin 1.6.10 -> 1.6.21 AtomicFu 0.17.1 -> 0.17.3","title":"Bumped"},{"location":"changelog/#010","text":"Initial release.","title":"0.1.0"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Versions currently being supported with security updates: Version Supported latest Reporting a Vulnerability \u00b6 Please use an Issue to report vulnerabilities. If security bug is discovered, following actions will be taken: Confirm the problem and determine the affected versions. Audit code to find any potential similar problems. Prepare fixes for all releases still under maintenance.","title":"Security Policy"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Versions currently being supported with security updates: Version Supported latest","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Please use an Issue to report vulnerabilities. If security bug is discovered, following actions will be taken: Confirm the problem and determine the affected versions. Audit code to find any potential similar problems. Prepare fixes for all releases still under maintenance.","title":"Reporting a Vulnerability"},{"location":"usage/","text":"Usage \u00b6 Getting started \u00b6 Assuming you are using MavenCentral already as repository, you just add the following into your projects build.gralde.kts : testImplementation ( \"tech.antibytes.kfixture:core: $ KFixtureVersion \" ) Generating Values \u00b6 While you initialise the Generator with kotlinFixture() you retrieve atomic values via the fixture extension: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : String = fixture . fixture () ... } } In opposite to JVM libraries, KFixture cannot generate values for arbitrary types due to the nature of KMP. This goes especially for Generics like List or Array. However KFixture has a preset of supported generic Types which can accessed via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . listFixture () ... } } or via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . fixture ( type = List :: class ) ... } } Note Nested Generics are not supported which means things like List<List<String>> cannot not be derived. Also fixture is capable to pick values from a given Iterable: class MySpec { private val fixture = kotlinFixture () private val possibleValues = listOf ( \"a\" , \"b\" , \"c\" ) @Test fun myAwesomeTest () { val value1 = fixture . fixture ( possibleValues ) val value2 = fixture . fixture ( 0. . 100 ) ... } } While you may have guessed it, KFixture uses Kotlin's Random implementation, which needs always a seed. The default value is set to 0, but you can set a custom value: class MySpec { private val fixture = kotlinFixture { seed = 42 } ... } Build-In types \u00b6 Atomics \u00b6 Following types are directly supported by the fixture extension: Type Any Boolean Byte Char Double Float Int Long Short String Unit UByte UInt ULong UShort Note String and Chars will be using Chars between (32) and ~ (126). A String will be composed of 1 to 10 Chars. Atomic Arrays \u00b6 Following types are directly supported by the fixture extension: Type BooleanArray ByteArray CharArray DoubleArray FloatArray IntArray LongArray ShortArray UByteArray UIntArray ULongArray UShortArray Note It will randomly choose a size between 1 and 10 items. Also an item of an CharArray will be a Char between (32) and ~ (126). Complex Types \u00b6 Iterables \u00b6 Type Corresponding Extension Sequence sequenceFixture Array arrayFixture List listFixture MutableList mutableListFixture Set setFixture MutableSet mutableSetFixture Map mapFixture MutableMap mutableMapFixture Note Except for pairFixture and tripleFixture you can define the size via size . If you do not set a value it will randomly choose a size between 1 and 10 items. Others \u00b6 Type Corresponding Extension Pair pairFixture Triple tripleFixture Customization \u00b6 In order to customize and extend KFixture you have 2 options. You can either simply build on top of the existing Extension Functions or you can create your own Generator. Note As a rule of thumb. You may use Extension especially when working with Generics or simple Dummies (like Data Classes). For special flavoured Atomics have to implement a custom Generator. Custom Extensions \u00b6 Extensions are likely the easiest way to extend KFixture. It will allow you to access the Random Generator as well as the Type Generators and of course existing Extensions. For example: import tech.antibytes.kfixture.PublicApi.Fixture class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private fun Fixture . somethingFixture (): Something { return Something ( value = fixture (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture () ... } } If you want to access the Type Generators you eventually need to derive the corresponding GeneratorId first. This is possible via resolveGeneratorId : import tech.antibytes.kfixture.PublicApi.Fixture import tech.antibytes.kfixture.PublicApi.Qualifier class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private inline fun < reified T > Fixture . somethingFixture ( qualifier : Qualifier? = null ): Something { val id = resolveGeneratorId ( T :: class , qualifier ) return Something ( value = generators [ id ] . generate (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture ( qualifiedBy ( \"me\" )) ... } } Custom Generators \u00b6 While Extension Function possibly not suite all use cases KFixture also let you define your own Type Generators. You can either define a Generator for entire Type (unqualified) or you can specialize it with an Qualifier. Both cases will make it available to the existing Extension Functions. In order to hook them in you can do the following: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.GeneratorFactory class MySpec { class MyAwesomeTypeGenerator ( private val random : Random ): Generator < MyAwesomeType > { override fun generate (): MyAwesomeType { ... } companion object : GeneratorFactory < MyAwesomeType > { override fun getInstance ( random : Random ): Generator < MyAwesomeType > = MyAwesomeTypeGenerator ( random ) } } class StringAlphaGenerator ( private val random : Random ) : Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = ByteArray ( length ) for ( idx in 0 until length ) { val char = random . nextInt ( 65 , 91 ) chars [ idx ] = if ( random . nextBoolean ()) { ( char + 32 ). toByte () } else { char . toByte () } } return chars . decodeToString () } companion object : GeneratorFactory < String > { override fun getInstance ( random : Random ): Generator < String > = StringAlphaGenerator ( random ) } } private val fixture = kotlinFixture { // unqualified addGenerator ( clazz = MyAwesomeType :: class , factory = MyAwesomeTypeGenerator ) // qualified addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) val awesomeValue : MyAwesomeType = fixture . fixture () ... } } In opposite to Extension Functions you will not have the the Fixture Scope at your disposal since Generators are initialized before it. However to overcome this you can always have an auxiliary Fixture, but this is not recommended. Important You are not allowed to override Build-In Types. You can only specialize them.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#getting-started","text":"Assuming you are using MavenCentral already as repository, you just add the following into your projects build.gralde.kts : testImplementation ( \"tech.antibytes.kfixture:core: $ KFixtureVersion \" )","title":"Getting started"},{"location":"usage/#generating-values","text":"While you initialise the Generator with kotlinFixture() you retrieve atomic values via the fixture extension: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : String = fixture . fixture () ... } } In opposite to JVM libraries, KFixture cannot generate values for arbitrary types due to the nature of KMP. This goes especially for Generics like List or Array. However KFixture has a preset of supported generic Types which can accessed via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . listFixture () ... } } or via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . fixture ( type = List :: class ) ... } } Note Nested Generics are not supported which means things like List<List<String>> cannot not be derived. Also fixture is capable to pick values from a given Iterable: class MySpec { private val fixture = kotlinFixture () private val possibleValues = listOf ( \"a\" , \"b\" , \"c\" ) @Test fun myAwesomeTest () { val value1 = fixture . fixture ( possibleValues ) val value2 = fixture . fixture ( 0. . 100 ) ... } } While you may have guessed it, KFixture uses Kotlin's Random implementation, which needs always a seed. The default value is set to 0, but you can set a custom value: class MySpec { private val fixture = kotlinFixture { seed = 42 } ... }","title":"Generating Values"},{"location":"usage/#build-in-types","text":"","title":"Build-In types"},{"location":"usage/#atomics","text":"Following types are directly supported by the fixture extension: Type Any Boolean Byte Char Double Float Int Long Short String Unit UByte UInt ULong UShort Note String and Chars will be using Chars between (32) and ~ (126). A String will be composed of 1 to 10 Chars.","title":"Atomics"},{"location":"usage/#atomic-arrays","text":"Following types are directly supported by the fixture extension: Type BooleanArray ByteArray CharArray DoubleArray FloatArray IntArray LongArray ShortArray UByteArray UIntArray ULongArray UShortArray Note It will randomly choose a size between 1 and 10 items. Also an item of an CharArray will be a Char between (32) and ~ (126).","title":"Atomic Arrays"},{"location":"usage/#complex-types","text":"","title":"Complex Types"},{"location":"usage/#iterables","text":"Type Corresponding Extension Sequence sequenceFixture Array arrayFixture List listFixture MutableList mutableListFixture Set setFixture MutableSet mutableSetFixture Map mapFixture MutableMap mutableMapFixture Note Except for pairFixture and tripleFixture you can define the size via size . If you do not set a value it will randomly choose a size between 1 and 10 items.","title":"Iterables"},{"location":"usage/#others","text":"Type Corresponding Extension Pair pairFixture Triple tripleFixture","title":"Others"},{"location":"usage/#customization","text":"In order to customize and extend KFixture you have 2 options. You can either simply build on top of the existing Extension Functions or you can create your own Generator. Note As a rule of thumb. You may use Extension especially when working with Generics or simple Dummies (like Data Classes). For special flavoured Atomics have to implement a custom Generator.","title":"Customization"},{"location":"usage/#custom-extensions","text":"Extensions are likely the easiest way to extend KFixture. It will allow you to access the Random Generator as well as the Type Generators and of course existing Extensions. For example: import tech.antibytes.kfixture.PublicApi.Fixture class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private fun Fixture . somethingFixture (): Something { return Something ( value = fixture (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture () ... } } If you want to access the Type Generators you eventually need to derive the corresponding GeneratorId first. This is possible via resolveGeneratorId : import tech.antibytes.kfixture.PublicApi.Fixture import tech.antibytes.kfixture.PublicApi.Qualifier class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private inline fun < reified T > Fixture . somethingFixture ( qualifier : Qualifier? = null ): Something { val id = resolveGeneratorId ( T :: class , qualifier ) return Something ( value = generators [ id ] . generate (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture ( qualifiedBy ( \"me\" )) ... } }","title":"Custom Extensions"},{"location":"usage/#custom-generators","text":"While Extension Function possibly not suite all use cases KFixture also let you define your own Type Generators. You can either define a Generator for entire Type (unqualified) or you can specialize it with an Qualifier. Both cases will make it available to the existing Extension Functions. In order to hook them in you can do the following: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.GeneratorFactory class MySpec { class MyAwesomeTypeGenerator ( private val random : Random ): Generator < MyAwesomeType > { override fun generate (): MyAwesomeType { ... } companion object : GeneratorFactory < MyAwesomeType > { override fun getInstance ( random : Random ): Generator < MyAwesomeType > = MyAwesomeTypeGenerator ( random ) } } class StringAlphaGenerator ( private val random : Random ) : Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = ByteArray ( length ) for ( idx in 0 until length ) { val char = random . nextInt ( 65 , 91 ) chars [ idx ] = if ( random . nextBoolean ()) { ( char + 32 ). toByte () } else { char . toByte () } } return chars . decodeToString () } companion object : GeneratorFactory < String > { override fun getInstance ( random : Random ): Generator < String > = StringAlphaGenerator ( random ) } } private val fixture = kotlinFixture { // unqualified addGenerator ( clazz = MyAwesomeType :: class , factory = MyAwesomeTypeGenerator ) // qualified addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) val awesomeValue : MyAwesomeType = fixture . fixture () ... } } In opposite to Extension Functions you will not have the the Fixture Scope at your disposal since Generators are initialized before it. However to overcome this you can always have an auxiliary Fixture, but this is not recommended. Important You are not allowed to override Build-In Types. You can only specialize them.","title":"Custom Generators"},{"location":"development/badges/","text":"Create a badge \u00b6 The badges are generate with Shields.io to generate our Badges. Use the following links in order to document or update any used badge and place the resulting SVG files the projects assets/images folder. Badges \u00b6 Latest release curl \"https://img.shields.io/badge/Release-0.5.0-blueviolet.svg?style=flat\" -s -o badge-release-latest.svg Platforms curl \"https://img.shields.io/badge/Platform-Android%20\u2022%20JVM%20\u2022%20Js%20\u2022%20iOS%20\u2022%20LinuxX64%20-blue.svg\" -s -o badge-release-latest.svg License curl \"https://img.shields.io/badge/license-Apache_2.0-blue.svg\" -s -o badge-license.svg License \u00b6 Shields is licensed under Creative Commons Zero v1.0 Universal (as of 2022-02-23)","title":"Badges"},{"location":"development/badges/#create-a-badge","text":"The badges are generate with Shields.io to generate our Badges. Use the following links in order to document or update any used badge and place the resulting SVG files the projects assets/images folder.","title":"Create a badge"},{"location":"development/badges/#badges","text":"Latest release curl \"https://img.shields.io/badge/Release-0.5.0-blueviolet.svg?style=flat\" -s -o badge-release-latest.svg Platforms curl \"https://img.shields.io/badge/Platform-Android%20\u2022%20JVM%20\u2022%20Js%20\u2022%20iOS%20\u2022%20LinuxX64%20-blue.svg\" -s -o badge-release-latest.svg License curl \"https://img.shields.io/badge/license-Apache_2.0-blue.svg\" -s -o badge-license.svg","title":"Badges"},{"location":"development/badges/#license","text":"Shields is licensed under Creative Commons Zero v1.0 Universal (as of 2022-02-23)","title":"License"},{"location":"development/code-of-conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body, size, disability, ethnicity, class, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior should be reported. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here .","title":"Code of Conduct"},{"location":"development/code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"development/code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body, size, disability, ethnicity, class, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"development/code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"development/code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"development/code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"development/code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior should be reported. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"development/code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here .","title":"Attribution"},{"location":"development/contributing/","text":"Contributing \u00b6 When contributing to this project, this document should help you get started. Code Of Conduct \u00b6 This project adheres to the Contributor Covenant Code Of Conduct . By participating, you are expected to uphold this code. Issues \u00b6 GitHub issues are the way to track bugs and enhancements. Issues are hold in high regards in this project, so please feel free to open issue for: Questions to help to improve the user experience Ideas which are a great source for contributions Problems show where this project is lacking or not working as expected. If you are reporting a problem, please provide as much information as possible, since this will help us to fix it. This includes, if possible, a description or small sample project how to reproduce the problem. Also please check out first if an issue had been already opened with your request. Contribute Code \u00b6 Development Process \u00b6 Prerequisites \u00b6 Android Studio 2021.3.1 or later Java 11 Kotlin 1.7.10 Gradle 7.5.1 Features \u00b6 Every change has to branch of from main and use this branch naming convention: feature/{type_of_change}-{short_description} main must be always in releasable state. Type Of Change \u00b6 add for new features or functionality change for changes in existing features or functionality deprecated for features which are at their end of life and will be removed in the future remove for removed features or functionality fix for any bug fixes bump for dependency updates security in case of vulnerabilities Examples: feature/add-awesome-hashing-algorithm feature/remove-not-so-awesome-algorithm feature/fix-algorithm-corner-case feature/bump-lib-to-1.3.0 Pull Request \u00b6 Pull requests are always welcome! If you (going to) contribute, please make sure you made clear which problem you are attempt solve or what is nature of your improvement. Create Pull Request \u00b6 Please use our title pattern: {type of change} {short description} : type of change can be: Add for new features or functionality, Change for changes in existing features or functionality, Deprecated for features which are at their end of life and will be removed in the future, Remove for removed features or functionality, Fix for any bug fixes, Security in case of vulnerabilities, Bump for dependency updates, followed by a short description of your change. Example: Add awesome hashing algorithm Changed thumbnail generation Pull requests must fill the provided template. Put N/A when a paragraph cannot be filled. Labels should be used (enhancement,bugfix, help wanted etc...) to categorise your contribution. Important : Work in progress pull-requests should be created as a draft. Code Review \u00b6 Your contribution has to meet these criteria: Functional and fitting in the project Code style and naming conventions followed Test written and passing Existing Tests still passing Continuous Integration build passing Cross platform testing done for all supported platforms Documentation updated (if necessary) Changelog updated (if necessary) Dependencies using other licenses \u00b6 Contributing code and introducing dependencies into the repository from other projects that use one of the following licenses is allowed. MIT ISC Apache 2.0 Any other contribution needs to be signed off by the project owners.","title":"Contributing"},{"location":"development/contributing/#contributing","text":"When contributing to this project, this document should help you get started.","title":"Contributing"},{"location":"development/contributing/#code-of-conduct","text":"This project adheres to the Contributor Covenant Code Of Conduct . By participating, you are expected to uphold this code.","title":"Code Of Conduct"},{"location":"development/contributing/#issues","text":"GitHub issues are the way to track bugs and enhancements. Issues are hold in high regards in this project, so please feel free to open issue for: Questions to help to improve the user experience Ideas which are a great source for contributions Problems show where this project is lacking or not working as expected. If you are reporting a problem, please provide as much information as possible, since this will help us to fix it. This includes, if possible, a description or small sample project how to reproduce the problem. Also please check out first if an issue had been already opened with your request.","title":"Issues"},{"location":"development/contributing/#contribute-code","text":"","title":"Contribute Code"},{"location":"development/contributing/#development-process","text":"","title":"Development Process"},{"location":"development/contributing/#prerequisites","text":"Android Studio 2021.3.1 or later Java 11 Kotlin 1.7.10 Gradle 7.5.1","title":"Prerequisites"},{"location":"development/contributing/#features","text":"Every change has to branch of from main and use this branch naming convention: feature/{type_of_change}-{short_description} main must be always in releasable state.","title":"Features"},{"location":"development/contributing/#type-of-change","text":"add for new features or functionality change for changes in existing features or functionality deprecated for features which are at their end of life and will be removed in the future remove for removed features or functionality fix for any bug fixes bump for dependency updates security in case of vulnerabilities Examples: feature/add-awesome-hashing-algorithm feature/remove-not-so-awesome-algorithm feature/fix-algorithm-corner-case feature/bump-lib-to-1.3.0","title":"Type Of Change"},{"location":"development/contributing/#pull-request","text":"Pull requests are always welcome! If you (going to) contribute, please make sure you made clear which problem you are attempt solve or what is nature of your improvement.","title":"Pull Request"},{"location":"development/contributing/#create-pull-request","text":"Please use our title pattern: {type of change} {short description} : type of change can be: Add for new features or functionality, Change for changes in existing features or functionality, Deprecated for features which are at their end of life and will be removed in the future, Remove for removed features or functionality, Fix for any bug fixes, Security in case of vulnerabilities, Bump for dependency updates, followed by a short description of your change. Example: Add awesome hashing algorithm Changed thumbnail generation Pull requests must fill the provided template. Put N/A when a paragraph cannot be filled. Labels should be used (enhancement,bugfix, help wanted etc...) to categorise your contribution. Important : Work in progress pull-requests should be created as a draft.","title":"Create Pull Request"},{"location":"development/contributing/#code-review","text":"Your contribution has to meet these criteria: Functional and fitting in the project Code style and naming conventions followed Test written and passing Existing Tests still passing Continuous Integration build passing Cross platform testing done for all supported platforms Documentation updated (if necessary) Changelog updated (if necessary)","title":"Code Review"},{"location":"development/contributing/#dependencies-using-other-licenses","text":"Contributing code and introducing dependencies into the repository from other projects that use one of the following licenses is allowed. MIT ISC Apache 2.0 Any other contribution needs to be signed off by the project owners.","title":"Dependencies using other licenses"},{"location":"development/releasing/","text":"Releasing \u00b6 Releases are automatically created from added tags using GitHub Actions. A tag needs to be in the form of v{major}.{minor}.{patch} . Release preparation \u00b6 Create a release branch of from main branch with this pattern: release/{major}.{minor}/prepare-{major}.{minor}.{patch} Update changelog.md by creating a new Unreleased section and change current unreleased to release version Update the latest release badge Release \u00b6 For a release, this project uses GitHub releases: Create a new release Set the tag Set the title Add a description in form of a changelog Publish when ready","title":"Releasing"},{"location":"development/releasing/#releasing","text":"Releases are automatically created from added tags using GitHub Actions. A tag needs to be in the form of v{major}.{minor}.{patch} .","title":"Releasing"},{"location":"development/releasing/#release-preparation","text":"Create a release branch of from main branch with this pattern: release/{major}.{minor}/prepare-{major}.{minor}.{patch} Update changelog.md by creating a new Unreleased section and change current unreleased to release version Update the latest release badge","title":"Release preparation"},{"location":"development/releasing/#release","text":"For a release, this project uses GitHub releases: Create a new release Set the tag Set the title Add a description in form of a changelog Publish when ready","title":"Release"},{"location":"usage/basic/","text":"Usage \u00b6 Getting started \u00b6 Assuming you are using MavenCentral already, you just add the following into your projects build.gralde.kts : testImplementation ( \"tech.antibytes.kfixture:core: $ KFixtureVersion \" ) Generating Values \u00b6 You initialise the Generator with kotlinFixture() and you may retrieve atomic values via the fixture extension: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : String = fixture . fixture () ... } } In opposite to JVM libraries, KFixture cannot generate values for arbitrary types due to the nature of KMP. This goes especially for Generics like List or Array. However KFixture has a preset of supported generic types which can accessed like: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . listFixture () ... } } or via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . fixture ( type = List :: class ) ... } } Note Nested Generics are not supported which means things like List<List<String>> cannot be derived in the default setting. Setting a Seed \u00b6 KFixture uses Kotlin's Random implementation to generate the most basic values. The default Random Seed value is set to 0, but you can set a custom value: class MySpec { private val fixture = kotlinFixture { seed = 42 } ... } Build-In types \u00b6 Atomics \u00b6 Following types are directly supported by the fixture extension: Type Any Boolean Byte Char Double Float Int Long Short Unit UByte UInt ULong UShort Note Chars will be between (32) and ~ (126). AtomicArrays \u00b6 Following types are directly supported by the fixture extension: Type BooleanArray ByteArray CharArray DoubleArray FloatArray IntArray LongArray ShortArray UByteArray UIntArray ULongArray UShortArray String Note It will randomly choose a size between 1 and 10 items. Also an item of an CharArray or String will be a Char between (32) and ~ (126). Complex Types \u00b6 Iterables \u00b6 Type Corresponding Extension Sequence sequenceFixture Array arrayFixture List listFixture MutableList mutableListFixture Set setFixture MutableSet mutableSetFixture Map mapFixture MutableMap mutableMapFixture Others \u00b6 Type Corresponding Extension Pair pairFixture Triple tripleFixture Enum enumFixture","title":"Basic"},{"location":"usage/basic/#usage","text":"","title":"Usage"},{"location":"usage/basic/#getting-started","text":"Assuming you are using MavenCentral already, you just add the following into your projects build.gralde.kts : testImplementation ( \"tech.antibytes.kfixture:core: $ KFixtureVersion \" )","title":"Getting started"},{"location":"usage/basic/#generating-values","text":"You initialise the Generator with kotlinFixture() and you may retrieve atomic values via the fixture extension: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : String = fixture . fixture () ... } } In opposite to JVM libraries, KFixture cannot generate values for arbitrary types due to the nature of KMP. This goes especially for Generics like List or Array. However KFixture has a preset of supported generic types which can accessed like: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . listFixture () ... } } or via: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : List < String > = fixture . fixture ( type = List :: class ) ... } } Note Nested Generics are not supported which means things like List<List<String>> cannot be derived in the default setting.","title":"Generating Values"},{"location":"usage/basic/#setting-a-seed","text":"KFixture uses Kotlin's Random implementation to generate the most basic values. The default Random Seed value is set to 0, but you can set a custom value: class MySpec { private val fixture = kotlinFixture { seed = 42 } ... }","title":"Setting a Seed"},{"location":"usage/basic/#build-in-types","text":"","title":"Build-In types"},{"location":"usage/basic/#atomics","text":"Following types are directly supported by the fixture extension: Type Any Boolean Byte Char Double Float Int Long Short Unit UByte UInt ULong UShort Note Chars will be between (32) and ~ (126).","title":"Atomics"},{"location":"usage/basic/#atomicarrays","text":"Following types are directly supported by the fixture extension: Type BooleanArray ByteArray CharArray DoubleArray FloatArray IntArray LongArray ShortArray UByteArray UIntArray ULongArray UShortArray String Note It will randomly choose a size between 1 and 10 items. Also an item of an CharArray or String will be a Char between (32) and ~ (126).","title":"AtomicArrays"},{"location":"usage/basic/#complex-types","text":"","title":"Complex Types"},{"location":"usage/basic/#iterables","text":"Type Corresponding Extension Sequence sequenceFixture Array arrayFixture List listFixture MutableList mutableListFixture Set setFixture MutableSet mutableSetFixture Map mapFixture MutableMap mutableMapFixture","title":"Iterables"},{"location":"usage/basic/#others","text":"Type Corresponding Extension Pair pairFixture Triple tripleFixture Enum enumFixture","title":"Others"},{"location":"usage/customization/","text":"Customization \u00b6 Since the default Generators may produce values in undesired range, KFixture has some possibilities to deal with that. Ranges \u00b6 Atomics \u00b6 Let's say you need an integer in the range of 12 to 42. You can set an additional range argument: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( from = 12 , to = 42 , ) ... } } Alternatively you can also use a ClosedRange: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( range = 12. . 42 , ) ... } } Note For numbers the default range goes over the entire range of the type. Chars however will be chosen between (32) and ~ (126). If you want simply to express that you want only positive/negative number, KFixture has a short cut for that: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( sign = Sign . POSITIVE , ) ... } } Note Float does not support signing. AtomicArrays \u00b6 AtomicArrays (e.g. ByteArray) have similar capacities as Atomics. They can use range arguments: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( from = 12 , to = 42 , ) ... } } or ClosedRange: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( 12. . 42 , ) ... } } or signing: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( sign = Sign . NEGATIVE , ) ... } } Additionally AtomicArrays can take multiple ranges. KFixture will randomly select a range per item: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( 12. . 42 , 102. . 222 , 143. . 567 ) ... } } Size \u00b6 AtomicArrays and build-in Generics (except Tuples and Enums) are also sizeable. This means they take an additional parameter - size - in order to determine the amount of items: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( size = 23 , ) ... } } Note If you do not set a size it will randomly choose one (between 1 and 10 items). Filter \u00b6 In some cases it might be desired to filter certain values out. KFixture provides for this a handle similar to Kotlin's filter . You may simply provide a predicate : class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( from = 12 , to = 42 , ) { it != 40 } // 40 will be excluded ... } } Nested Generators \u00b6 In order to keep Generics agnostic they will not take a concrete parameter like predicate . However all Generic Generators will allow you to inject a customized Generator via nestedGenerator or similar: class MySpec { private val fixture = kotlinFixture () private inline fun < reified T : Number > positiveNumber ( qualifier : PublicApi . Qualifier ? ): T = fixture . fixture ( sign = PublicApi . Sign . POSITIVE ) @Test fun myAwesomeTest () { val value : List < Int > = fixture . listFixture ( nestedGenerator = :: positiveNumber ) ... } } Selections \u00b6 Inline \u00b6 fixture is also capable to pick values from a given Iterable: class MySpec { private val fixture = kotlinFixture () private val possibleValues = listOf ( \"a\" , \"b\" , \"c\" ) @Test fun myAwesomeTest () { val value1 = fixture . fixture ( possibleValues ) val value2 = fixture . fixture ( 0. . 100 ) ... } } Selection Generator \u00b6 If you want to distribute options over the entire lifetime of fixture you can use the SelectionGenerator : class MySpec { private val fixture = kotlinFixture { useSelector ( options = listOf ( \"a\" , \"b\" , \"c\" ), qualifier = qualifiedBy ( \"abc\" ) ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"abc\" ) ) ... } } The selector will pick a value of the provided option list whenever it is referenced. You also may noticed the usage of a qualifier. Qualifiers are described in under Extensions , so please take a look there. Overview \u00b6 Atomics \u00b6 Type Range Signed Filterable Any \u274c \u274c \u274c Boolean \u274c \u274c \u274c Byte \u2705 \u2705 \u2705 Char \u2705 \u274c \u2705 Double \u2705 \u2705 \u2705 Float \u2705 \u274c \u2705 Int \u2705 \u2705 \u2705 Long \u2705 \u2705 \u2705 Short \u2705 \u2705 \u2705 Unit \u274c \u274c \u274c UByte \u2705 \u274c \u2705 UInt \u2705 \u274c \u2705 ULong \u2705 \u274c \u2705 UShort \u2705 \u274c \u2705 AtomicArrays \u00b6 Type Range Signed Filterable BooleanArray \u274c \u274c \u274c ByteArray \u2705 \u2705 \u2705 CharArray \u2705 \u274c \u2705 String \u2705 \u274c \u2705 DoubleArray \u2705 \u2705 \u2705 FloatArray \u2705 \u274c \u2705 IntArray \u2705 \u2705 \u2705 LongArray \u2705 \u2705 \u2705 ShortArray \u2705 \u2705 \u2705 UByteArray \u2705 \u274c \u2705 UIntArray \u2705 \u274c \u2705 ULongArray \u2705 \u274c \u2705 UShortArray \u2705 \u274c \u2705","title":"Customization"},{"location":"usage/customization/#customization","text":"Since the default Generators may produce values in undesired range, KFixture has some possibilities to deal with that.","title":"Customization"},{"location":"usage/customization/#ranges","text":"","title":"Ranges"},{"location":"usage/customization/#atomics","text":"Let's say you need an integer in the range of 12 to 42. You can set an additional range argument: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( from = 12 , to = 42 , ) ... } } Alternatively you can also use a ClosedRange: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( range = 12. . 42 , ) ... } } Note For numbers the default range goes over the entire range of the type. Chars however will be chosen between (32) and ~ (126). If you want simply to express that you want only positive/negative number, KFixture has a short cut for that: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : Int = fixture . fixture ( sign = Sign . POSITIVE , ) ... } } Note Float does not support signing.","title":"Atomics"},{"location":"usage/customization/#atomicarrays","text":"AtomicArrays (e.g. ByteArray) have similar capacities as Atomics. They can use range arguments: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( from = 12 , to = 42 , ) ... } } or ClosedRange: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( 12. . 42 , ) ... } } or signing: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( sign = Sign . NEGATIVE , ) ... } } Additionally AtomicArrays can take multiple ranges. KFixture will randomly select a range per item: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( 12. . 42 , 102. . 222 , 143. . 567 ) ... } }","title":"AtomicArrays"},{"location":"usage/customization/#size","text":"AtomicArrays and build-in Generics (except Tuples and Enums) are also sizeable. This means they take an additional parameter - size - in order to determine the amount of items: class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( size = 23 , ) ... } } Note If you do not set a size it will randomly choose one (between 1 and 10 items).","title":"Size"},{"location":"usage/customization/#filter","text":"In some cases it might be desired to filter certain values out. KFixture provides for this a handle similar to Kotlin's filter . You may simply provide a predicate : class MySpec { private val fixture = kotlinFixture () @Test fun myAwesomeTest () { val value : IntArray = fixture . fixture ( from = 12 , to = 42 , ) { it != 40 } // 40 will be excluded ... } }","title":"Filter"},{"location":"usage/customization/#nested-generators","text":"In order to keep Generics agnostic they will not take a concrete parameter like predicate . However all Generic Generators will allow you to inject a customized Generator via nestedGenerator or similar: class MySpec { private val fixture = kotlinFixture () private inline fun < reified T : Number > positiveNumber ( qualifier : PublicApi . Qualifier ? ): T = fixture . fixture ( sign = PublicApi . Sign . POSITIVE ) @Test fun myAwesomeTest () { val value : List < Int > = fixture . listFixture ( nestedGenerator = :: positiveNumber ) ... } }","title":"Nested Generators"},{"location":"usage/customization/#selections","text":"","title":"Selections"},{"location":"usage/customization/#inline","text":"fixture is also capable to pick values from a given Iterable: class MySpec { private val fixture = kotlinFixture () private val possibleValues = listOf ( \"a\" , \"b\" , \"c\" ) @Test fun myAwesomeTest () { val value1 = fixture . fixture ( possibleValues ) val value2 = fixture . fixture ( 0. . 100 ) ... } }","title":"Inline"},{"location":"usage/customization/#selection-generator","text":"If you want to distribute options over the entire lifetime of fixture you can use the SelectionGenerator : class MySpec { private val fixture = kotlinFixture { useSelector ( options = listOf ( \"a\" , \"b\" , \"c\" ), qualifier = qualifiedBy ( \"abc\" ) ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"abc\" ) ) ... } } The selector will pick a value of the provided option list whenever it is referenced. You also may noticed the usage of a qualifier. Qualifiers are described in under Extensions , so please take a look there.","title":"Selection Generator"},{"location":"usage/customization/#overview","text":"","title":"Overview"},{"location":"usage/customization/#atomics_1","text":"Type Range Signed Filterable Any \u274c \u274c \u274c Boolean \u274c \u274c \u274c Byte \u2705 \u2705 \u2705 Char \u2705 \u274c \u2705 Double \u2705 \u2705 \u2705 Float \u2705 \u274c \u2705 Int \u2705 \u2705 \u2705 Long \u2705 \u2705 \u2705 Short \u2705 \u2705 \u2705 Unit \u274c \u274c \u274c UByte \u2705 \u274c \u2705 UInt \u2705 \u274c \u2705 ULong \u2705 \u274c \u2705 UShort \u2705 \u274c \u2705","title":"Atomics"},{"location":"usage/customization/#atomicarrays_1","text":"Type Range Signed Filterable BooleanArray \u274c \u274c \u274c ByteArray \u2705 \u2705 \u2705 CharArray \u2705 \u274c \u2705 String \u2705 \u274c \u2705 DoubleArray \u2705 \u2705 \u2705 FloatArray \u2705 \u274c \u2705 IntArray \u2705 \u2705 \u2705 LongArray \u2705 \u2705 \u2705 ShortArray \u2705 \u2705 \u2705 UByteArray \u2705 \u274c \u2705 UIntArray \u2705 \u274c \u2705 ULongArray \u2705 \u274c \u2705 UShortArray \u2705 \u274c \u2705","title":"AtomicArrays"},{"location":"usage/datetime/","text":"kotlinx-datetime Extension \u00b6 Setup \u00b6 To make the extension available in your code add: testImplementation ( \"tech.antibytes.kfixture:ktx-datetime: $ KFixtureVersion \" ) Please not that this Extension is dependent on kotlinx-datetime . If all requirements are fulfilled you can hook in the Extension via useDatTimeWithOnlyUtc or useDateTimeWithTimeZones like: val fixture = kotlinFixture { useDateTimeWithOnlyUtc () } The difference between useDatTimeWithOnlyUtc and useDateTimeWithTimeZones depends on Javascript as described here . In opposite to kotlinx-datetime KFixture will either only support UTC or all (joda) timezones . !!!note: The timezones from platform to platform differ Supported Types \u00b6 The Extension brings the following additional types: Type Instant DayOfWeek Month TimeZone DateTimePeriod DatePeriod UtcOffset FixedOffsetTimeZone LocalTime LocalDate LocalDateTime Additional Extension Functions \u00b6 While all types are implemented as Generators; LocalTime , LocalDate and LocalDateTime have a additional Extension Function, which allows nested Generators for its Instant and TimeZone: val dateTime : LocalDateTime = fixture . fixture ( instantGenerator = { Instant . fromEpochMilliseconds ( 502131 ) }, timeZoneGenerator = { TimeZone . of ( \"Europe/Berlin\" ) }, ) Both nested generators are optional. Extension Overview \u00b6 Type Range Filterable Nested DateTime Generator Instant \u2705 \u2705 \u274c DayOfWeek \u274c \u2705 \u274c DateTimePeriod \u274c \u2705 \u274c DatePeriod \u274c \u2705 \u274c UtcOffset \u274c \u2705 \u274c FixedOffsetTimeZone \u274c \u2705 \u274c LocalTime \u274c \u274c \u2705 LocalDate \u274c \u274c \u2705 LocalDateTime \u274c \u274c \u2705","title":"DateTime"},{"location":"usage/datetime/#kotlinx-datetime-extension","text":"","title":"kotlinx-datetime Extension"},{"location":"usage/datetime/#setup","text":"To make the extension available in your code add: testImplementation ( \"tech.antibytes.kfixture:ktx-datetime: $ KFixtureVersion \" ) Please not that this Extension is dependent on kotlinx-datetime . If all requirements are fulfilled you can hook in the Extension via useDatTimeWithOnlyUtc or useDateTimeWithTimeZones like: val fixture = kotlinFixture { useDateTimeWithOnlyUtc () } The difference between useDatTimeWithOnlyUtc and useDateTimeWithTimeZones depends on Javascript as described here . In opposite to kotlinx-datetime KFixture will either only support UTC or all (joda) timezones . !!!note: The timezones from platform to platform differ","title":"Setup"},{"location":"usage/datetime/#supported-types","text":"The Extension brings the following additional types: Type Instant DayOfWeek Month TimeZone DateTimePeriod DatePeriod UtcOffset FixedOffsetTimeZone LocalTime LocalDate LocalDateTime","title":"Supported Types"},{"location":"usage/datetime/#additional-extension-functions","text":"While all types are implemented as Generators; LocalTime , LocalDate and LocalDateTime have a additional Extension Function, which allows nested Generators for its Instant and TimeZone: val dateTime : LocalDateTime = fixture . fixture ( instantGenerator = { Instant . fromEpochMilliseconds ( 502131 ) }, timeZoneGenerator = { TimeZone . of ( \"Europe/Berlin\" ) }, ) Both nested generators are optional.","title":"Additional Extension Functions"},{"location":"usage/datetime/#extension-overview","text":"Type Range Filterable Nested DateTime Generator Instant \u2705 \u2705 \u274c DayOfWeek \u274c \u2705 \u274c DateTimePeriod \u274c \u2705 \u274c DatePeriod \u274c \u2705 \u274c UtcOffset \u274c \u2705 \u274c FixedOffsetTimeZone \u274c \u2705 \u274c LocalTime \u274c \u274c \u2705 LocalDate \u274c \u274c \u2705 LocalDateTime \u274c \u274c \u2705","title":"Extension Overview"},{"location":"usage/extension/","text":"Extensions \u00b6 In order to extend KFixture you have 2 options. You can either simply build on top of the existing Extension Functions or you can create your own Generator. Custom Extensions \u00b6 Extensions are likely the easiest way to extend KFixture. It will allow you to access the Random Generator as well as the Type Generators and of course existing Extensions. For example: import tech.antibytes.kfixture.PublicApi.Fixture class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private fun Fixture . somethingFixture (): Something { return Something ( value = fixture (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture () ... } } If you want to access the Type Generators you eventually need to derive the corresponding GeneratorId first. This is possible via resolveGeneratorId : import tech.antibytes.kfixture.PublicApi.Fixture import tech.antibytes.kfixture.PublicApi.Qualifier class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private inline fun < reified T > Fixture . somethingFixture ( qualifier : Qualifier? = null ): Something { val id = resolveGeneratorId ( T :: class , qualifier ) return Something ( value = generators [ id ] . generate (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture ( qualifiedBy ( \"me\" )) ... } } Custom Generators \u00b6 KFixture also let you define your own Generators which might come in handy when used in tandem with for example KMock . You can either define a Generator for an entire Type (unqualified) or you can specialize it with an Qualifier. Both cases will make it available to the existing Extension Functions. In order to hook them in you can do the following: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.GeneratorFactory class MySpec { class MyAwesomeTypeGenerator ( private val random : Random ): Generator < MyAwesomeType > { override fun generate (): MyAwesomeType { ... } companion object : GeneratorFactory < MyAwesomeType > { override fun getInstance ( random : Random ): Generator < MyAwesomeType > = MyAwesomeTypeGenerator ( random ) } } class StringAlphaGenerator ( private val random : Random ) : Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = ByteArray ( length ) for ( idx in 0 until length ) { val char = random . nextInt ( 65 , 91 ) chars [ idx ] = if ( random . nextBoolean ()) { ( char + 32 ). toByte () } else { char . toByte () } } return chars . decodeToString () } companion object : GeneratorFactory < String > { override fun getInstance ( random : Random ): Generator < String > = StringAlphaGenerator ( random ) } } private val fixture = kotlinFixture { // unqualified addGenerator ( clazz = MyAwesomeType :: class , factory = MyAwesomeTypeGenerator ) // qualified addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) val awesomeValue : MyAwesomeType = fixture . fixture () ... } } Unlike with Extension Functions you will not have the Fixture scope, but you can define dependencies. This allows you to make use of already registered Generators. Let's refactor the example above while we use the build-in Char Generator: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.DependentGeneratorFactory import tech.antibytes.kfixture.PublicApi.RangedGenerator class MySpec { class StringAlphaGenerator ( private val charGenerator : PublicApi . RangedGenerator < Char , Char > , private val random : Random , ) : PublicApi . Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = CharArray ( length ) { val char = charGenerator . generate ( from = 'A' , to = 'Z' , ) if ( random . nextBoolean ()) { char + 32 } else { char } } return chars . concatToString () } @Suppress ( \"UNCHECKED_CAST\" ) companion object : PublicApi . DependentGeneratorFactory < String > { override fun getInstance ( random : Random , generators : Map < String , PublicApi . Generator < out Any >> ): PublicApi . Generator < String > { return StringAlphaGenerator ( charGenerator = generators [ resolveGeneratorId ( Char :: class ) ] as PublicApi . RangedGenerator < Char , Char > , random = random ) } } } private val fixture = kotlinFixture { addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) ... } } If this still not fits entirely your needs you may overcome this by using auxiliary Fixture. Go this path only when it is really necessary. Important You are not allowed to override Build-In Types. You can only specialize them. Type Overview \u00b6 You may find the definitions of the Interfaces in PublicApi . However the following should provide you with missing information about the build-in types: Atomics \u00b6 Type Interface Any Generator<Any> Boolean Generator<Boolean> Byte SignedNumberGenerator<Byte, Byte> Char RangedGenerator<Char, Char> Double SignedNumberGenerator<Double, Double> Float RangedGenerator<Float, Float> Int SignedNumberGenerator<Int, Int> Long SignedNumberGenerator<Long, Long> Short SignedNumberGenerator<Short, Short> Unit Generator<Unit> UByte RangedGenerator<UByte, UByte> UInt RangedGenerator<UInt, UInt> ULong RangedGenerator<ULong, ULong> UShort RangedGenerator<UShort, UShort> AtomicArrays \u00b6 Type Interface BooleanArray ArrayGenerator<Boolean, BooleanArray> ByteArray SignedNumericArrayGenerator<Byte, ByteArray> CharArray RangedArrayGenerator<Char, CharArray> String RangedArrayGenerator<Char, String> DoubleArray SignedNumericArrayGenerator<Double, DoubleArray> FloatArray RangedArrayGenerator<Float, FloatArray> IntArray SignedNumericArrayGenerator<Int, IntArray> LongArray SignedNumericArrayGenerator<Long, LongArray> ShortArray SignedNumericArrayGenerator<Short, ShortArray> UByteArray RangedArrayGenerator<UByte, UByteArray> UIntArray RangedArrayGenerator<UInt, UIntArray> ULongArray RangedArrayGenerator<ULong, ULongArray> UShortArray RangedArrayGenerator<UShort, UShortArray>","title":"Extension"},{"location":"usage/extension/#extensions","text":"In order to extend KFixture you have 2 options. You can either simply build on top of the existing Extension Functions or you can create your own Generator.","title":"Extensions"},{"location":"usage/extension/#custom-extensions","text":"Extensions are likely the easiest way to extend KFixture. It will allow you to access the Random Generator as well as the Type Generators and of course existing Extensions. For example: import tech.antibytes.kfixture.PublicApi.Fixture class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private fun Fixture . somethingFixture (): Something { return Something ( value = fixture (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture () ... } } If you want to access the Type Generators you eventually need to derive the corresponding GeneratorId first. This is possible via resolveGeneratorId : import tech.antibytes.kfixture.PublicApi.Fixture import tech.antibytes.kfixture.PublicApi.Qualifier class MySpec { data class Something ( val value : String , val otherValue : Int ) private val fixture = kotlinFixture () private inline fun < reified T > Fixture . somethingFixture ( qualifier : Qualifier? = null ): Something { val id = resolveGeneratorId ( T :: class , qualifier ) return Something ( value = generators [ id ] . generate (), otherValue = fixture () ) } @Test fun myAwesomeTest () { val value = fixture . somethingFixture ( qualifiedBy ( \"me\" )) ... } }","title":"Custom Extensions"},{"location":"usage/extension/#custom-generators","text":"KFixture also let you define your own Generators which might come in handy when used in tandem with for example KMock . You can either define a Generator for an entire Type (unqualified) or you can specialize it with an Qualifier. Both cases will make it available to the existing Extension Functions. In order to hook them in you can do the following: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.GeneratorFactory class MySpec { class MyAwesomeTypeGenerator ( private val random : Random ): Generator < MyAwesomeType > { override fun generate (): MyAwesomeType { ... } companion object : GeneratorFactory < MyAwesomeType > { override fun getInstance ( random : Random ): Generator < MyAwesomeType > = MyAwesomeTypeGenerator ( random ) } } class StringAlphaGenerator ( private val random : Random ) : Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = ByteArray ( length ) for ( idx in 0 until length ) { val char = random . nextInt ( 65 , 91 ) chars [ idx ] = if ( random . nextBoolean ()) { ( char + 32 ). toByte () } else { char . toByte () } } return chars . decodeToString () } companion object : GeneratorFactory < String > { override fun getInstance ( random : Random ): Generator < String > = StringAlphaGenerator ( random ) } } private val fixture = kotlinFixture { // unqualified addGenerator ( clazz = MyAwesomeType :: class , factory = MyAwesomeTypeGenerator ) // qualified addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) val awesomeValue : MyAwesomeType = fixture . fixture () ... } } Unlike with Extension Functions you will not have the Fixture scope, but you can define dependencies. This allows you to make use of already registered Generators. Let's refactor the example above while we use the build-in Char Generator: import tech.antibytes.kfixture.PublicApi.Generator import tech.antibytes.kfixture.PublicApi.DependentGeneratorFactory import tech.antibytes.kfixture.PublicApi.RangedGenerator class MySpec { class StringAlphaGenerator ( private val charGenerator : PublicApi . RangedGenerator < Char , Char > , private val random : Random , ) : PublicApi . Generator < String > { override fun generate (): String { val length = random . nextInt ( 1 , 10 ) val chars = CharArray ( length ) { val char = charGenerator . generate ( from = 'A' , to = 'Z' , ) if ( random . nextBoolean ()) { char + 32 } else { char } } return chars . concatToString () } @Suppress ( \"UNCHECKED_CAST\" ) companion object : PublicApi . DependentGeneratorFactory < String > { override fun getInstance ( random : Random , generators : Map < String , PublicApi . Generator < out Any >> ): PublicApi . Generator < String > { return StringAlphaGenerator ( charGenerator = generators [ resolveGeneratorId ( Char :: class ) ] as PublicApi . RangedGenerator < Char , Char > , random = random ) } } } private val fixture = kotlinFixture { addGenerator ( clazz = String :: class , factory = StringAlphaGenerator , qualifier = qualifiedBy ( \"special\" ), ) } @Test fun myAwesomeTest () { val value : String = fixture . fixture ( qualifier = qualifiedBy ( \"special\" ) ) ... } } If this still not fits entirely your needs you may overcome this by using auxiliary Fixture. Go this path only when it is really necessary. Important You are not allowed to override Build-In Types. You can only specialize them.","title":"Custom Generators"},{"location":"usage/extension/#type-overview","text":"You may find the definitions of the Interfaces in PublicApi . However the following should provide you with missing information about the build-in types:","title":"Type Overview"},{"location":"usage/extension/#atomics","text":"Type Interface Any Generator<Any> Boolean Generator<Boolean> Byte SignedNumberGenerator<Byte, Byte> Char RangedGenerator<Char, Char> Double SignedNumberGenerator<Double, Double> Float RangedGenerator<Float, Float> Int SignedNumberGenerator<Int, Int> Long SignedNumberGenerator<Long, Long> Short SignedNumberGenerator<Short, Short> Unit Generator<Unit> UByte RangedGenerator<UByte, UByte> UInt RangedGenerator<UInt, UInt> ULong RangedGenerator<ULong, ULong> UShort RangedGenerator<UShort, UShort>","title":"Atomics"},{"location":"usage/extension/#atomicarrays","text":"Type Interface BooleanArray ArrayGenerator<Boolean, BooleanArray> ByteArray SignedNumericArrayGenerator<Byte, ByteArray> CharArray RangedArrayGenerator<Char, CharArray> String RangedArrayGenerator<Char, String> DoubleArray SignedNumericArrayGenerator<Double, DoubleArray> FloatArray RangedArrayGenerator<Float, FloatArray> IntArray SignedNumericArrayGenerator<Int, IntArray> LongArray SignedNumericArrayGenerator<Long, LongArray> ShortArray SignedNumericArrayGenerator<Short, ShortArray> UByteArray RangedArrayGenerator<UByte, UByteArray> UIntArray RangedArrayGenerator<UInt, UIntArray> ULongArray RangedArrayGenerator<ULong, ULongArray> UShortArray RangedArrayGenerator<UShort, UShortArray>","title":"AtomicArrays"}]}